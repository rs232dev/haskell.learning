

** ********************************************************************************************** **
**                                     Table of contents                                          **
** ********************************************************************************************** **

   1) Create VsCode project
   2) Show   VsCode preferences
   3) Set Vscode terminal
   4) Haskell Main
   5) Haskell Comments
   6) Cap_3_4 Variables_and_Functions
   7) Cap_5 Type Basics
   8) Cap_6 List and Tuples
   9) Cap_7 Type Basics II
  10) Cap_8 Building vocabulary
  11) Cap_9 Next Steps + Pattern Matching     
  12) Cap_10 Simple input and ouput
  13) Cap_12 Recursion
  14) Cap_13 More about Lists
  15) Cap_14 List Processing 
  16) Cap_15.Type_Declarations 
  17) Cap_16.Pattern_Matching   
  18) Cap_17.Control_Structures
  19) Cap_18.More_on_Functions 
  20) Cap_19.High_Order_Functions
  21) Cap_22.Modules
  22) Cap_24.More_on_datatypes
  23) Cap_26.Classes_and_Types
  24) Cap_27.Functor_class
  25) Cap_29_PrologueIO_ApplicativeFunctor

-- ---------------------------------------------------------------------------------------------- --
--  1) Create VsCode project                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --

host@hskuser:~/dev/vscode.wks/haskell.learning/haskell.wikibooks$ stack new HaskellBasic new-template
Downloading template "new-template" to create project "HaskellBasic" in HaskellBasic/ ...

The following parameters were needed by the template but not provided: author-name
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-name: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-name:value"


The following parameters were needed by the template but not provided: author-email, author-name, category, copyright, github-username
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-email: value
    author-name: value
    category: value
    copyright: value
    github-username: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-email:value" -p "author-name:value" -p "category:value" -p "copyright:value" -p "github-username:value"

Looking for .cabal or package.yaml files to use to init the project.
Using cabal packages:

- HaskellBasic/

Selecting the best among 15 snapshots...

Downloaded lts-13.18 build plan.    
Didn't see Chart-1.9.1@sha256:cc50e1e65738ab2d6c30ae9e3f138962f87667d81f7860a0deeca9053f6d21ed,2857 in your package indices.
Updating and trying again.
Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/                                 
Downloading timestamp                                                                            
Downloading snapshot                                                                             
Updating index                                                                                   
Updated package index downloaded                                                                 
Update complete                                                                                  
Populated index cache.    
* Matches lts-13.18

Selected resolver: lts-13.18
Initialising configuration using resolver: lts-13.18
Total number of user packages considered: 1
Writing configuration to file: HaskellBasic/stack.yaml
All done.


-- ---------------------------------------------------------------------------------------------- --
-- 2) Show   VsCode preferences                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --

VsCode Preferences:
Creating User and Workspace Settings
To open your user and workspace settings, use the following VS Code menu command:

    On Windows/Linux - File > Preferences > Settings
    On macOS - Code > Preferences > Settings

You can also open the Settings editor from the Command Palette (Ctrl+Shift+P) with Preferences: Open Settings or use the keyboard shortcut (Ctrl+,).


-- ---------------------------------------------------------------------------------------------- --
--  3) Set Vscode terminal                                                                        -- 
-- ---------------------------------------------------------------------------------------------- --

export LC_ALL=en_US.UTF-8
ghci -isrc:app app/Main.hs
Prelude> :set prompt "\x03BB:"


-- ---------------------------------------------------------------------------------------------- --
-- 4) Haskell Main                                                                                -- 
-- ---------------------------------------------------------------------------------------------- --

module Main where

import Lib
import Cap_3.Variables_and_Functions

main :: IO ()
main = do

    putStrLn "haskell basic course ";    


-- ---------------------------------------------------------------------------------------------- --
-- 5) Haskell Comments                                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

-- single line comment
{--
     multi lines comment
--}

-- ---------------------------------------------------------------------------------------------- --
--  6) Cap_3_4 Variables_and_Functions                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Local definition
    - Prefix Infix operators
    - Boolean operations
    - Guards

-- ---------------------------------------------------------------------------------------------- --
--  7) Cap_5 Type Basics                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Haskell is STRONGLY TYPED

-- ---------------------------------------------------------------------------------------------- --
--  8) Cap_6 List and Tuples                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --    
    - List
    - Building a List
    - List of Lists
    - Tuples
    - Retrieve values
    - Tuples within Tuples
    - Polymorphic types

-- ---------------------------------------------------------------------------------------------- --
--  9) Cap_7 Type Basics II                                                                       -- 
-- ---------------------------------------------------------------------------------------------- --        
    - The Num class

-- ---------------------------------------------------------------------------------------------- --
--  10) Cap_8 Building vocabulary                                                                 -- 
-- ---------------------------------------------------------------------------------------------- --        
    - Function Composition:

        Function Composition is a really simply concept.
        It just means applying one function to a value and then applying another function to the
        result.

    - Prelude and hierarchical libraries:

        Prelude is the core library loaded by default in every Haskell program.

    Alongside with Prelude, there are the hierarchical libraries, which provide a much wider
    range of functionality.
    Although they are provided by default with GHC, they are not loaded automatically like
    Prelude.
    Rather they are distributed as modules, which must be imported into your program.

    ex.

    import Data.List


    For quick GHCi tests, just enter :m +Data.List at the command line to load that module.

    Prelude> :m +Data.List
    Prelude Data.List> :t permutations    
    permutations :: [a] -> a

    Resources:

    https://en.wikibooks.org/wiki/..%2FHierarchical%20libraries
    http://www.haskell.org/onlinereport/standard-prelude.html
    http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
    http://www.haskell.org/hoogle
    https://hackage.haskell.org/
    http://www.haskell.org/cabal/users-guide/
    http://holumbus.fh-wedel.de/hayoo/hayoo.html


-- ---------------------------------------------------------------------------------------------- --
--  11) Cap_9 Next Steps                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --       

    - if/then/else
    - if/then/else by Guards
    - Pattern Matching
    - Tuples and Lists Pattern
    - let bindings

-- ---------------------------------------------------------------------------------------------- --
--  12) Cap_10 Simple input and ouput                                                             -- 
-- ---------------------------------------------------------------------------------------------- --       

    -- ----------------------
    -- Back to the real world
    -- ----------------------
    
      Prelude> putStrLn "Hello, World!"

    putStrLn is one of the standard Prelude tools. As the "putStr" part of the name suggests,
    it takes a String as an argument and prints it to the screen. We could use putStr on its
    own, but we usually include the ”Ln” part so to also print a line break. Thus, whatever else
    is printed next will appear on a new line.

    So now you should be thinking, "what is the type of the putStrLn function?" 
      
    It takes a String and gives... um... what? What do we call that? 
      
    The program doesn't get something back that it can use in another function. 
      
    Instead, the result involves having the computer change the screen. 
    In other words, it does something in the world outside of the program.

    What type could that have? Let's see what GHCi tells us:

        Prelude> :t putStrLn
        putStrLn :: String -> IO ()

    "IO" stands for "input and output"

    Wherever there is IO in a type, interaction with the world outside the program is involved.
    We'll call these IO values actions. 
      
    The other part of the IO type, in this case (), is the type of the return value of the action;
    that is, the type of what it gives back to the program (as opposed to what it does outside 
    the program). 
      
      () (pronounced as ”unit”) is a type that only contains one value also called () 
         (effectively a tuple with zero elements).

    Since putStrLn sends output to the world but doesn't return
    anything to the program, () is used as a placeholder. We might read IO () as 
    "action which returns ()".    

    A few more examples of when we use IO:
    
    - print a string to the screen
    - read a string from a keyboard
    - write data to a file
    - read data from a file

    A complete Haskell program is actually a big IO action. In a compiled program, this action 
    is called main and has type IO (). From this point of view, to write a Haskell program is 
    to combine actions and functions to form the overall action main that will be executed when 
    the program is run. The compiler takes care of instructing the computer on how to do this.    

    -- ----------------------
    -- do notation
    -- ----------------------

    do notation provides a convenient means of putting actions together (which is essential in
    doing useful things with Haskell).

-- ---------------------------------------------------------------------------------------------- --
--  13) Cap_12 Recursion                                                                          -- 
-- ---------------------------------------------------------------------------------------------- -- 

    - Recursion:
       Recursion is the idea of defining a function in terms of itself.

    - List based Recursion 

-- ---------------------------------------------------------------------------------------------- --
--  14) Cap_13 More about Lists                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --           

    - map function
    - Dot Dot Notation
    - Infinite Lists
    - Prelude null fuction
    

-- ---------------------------------------------------------------------------------------------- --
--  15) Cap_14 List Processing                                                                    -- 
-- ---------------------------------------------------------------------------------------------- --      

    - Folds 
        - foldr
        - foldl
        - scans
        - filter
        - List comprehensions

-- ---------------------------------------------------------------------------------------------- --
--  16) Cap_15.Type_Declarations                                                                  -- 
-- ---------------------------------------------------------------------------------------------- --      

    You're not restricted to working with just the types provided by default with the language.
    
    Haskell has three basic ways to declare a new type:

    - The data declaration, which defines new data types.
    - The type declaration for type synonyms, that is, alternative names for existing types.
    - The newtype declaration, which defines new data types equivalent to existing ones.

    - data and constructor functions
    - deconstructing types
    - type for making type synonyms

-- ---------------------------------------------------------------------------------------------- --
--  17) Cap_16.Pattern_Matching                                                                   --
-- ---------------------------------------------------------------------------------------------- --

    - Pattern Matching

    Some languages like Perl and Python use term pattern matching for matching regular expression
    against strings.
    The pattern matching we are referring to in this chapter is something completely different.
    Here pattern matching is used to deconstruct values according  to their type specification.

    - Tuple constructors
    - Matching literal values

    - Syntax_Tricks
        - As-patterns

-- ---------------------------------------------------------------------------------------------- --
--  18) Cap_17.Control_Structures                                                                 --
-- ---------------------------------------------------------------------------------------------- --
    - if and guards revisited
    - Embedding if expressions
    - case expressions
    - Controlling actions, revisited

-- ---------------------------------------------------------------------------------------------- --
--  19) Cap_18.More_on_Functions                                                                  --
-- ---------------------------------------------------------------------------------------------- --

    - let and where:

        As discussed in earlier chapters, let and where are useful in local function definitions. 
        Here, sumStr calls addStr function:

    - Anonymous_Functions - lambdas
    - Operators

-- ---------------------------------------------------------------------------------------------- --
--  20) Cap_19.High_Order_Functions                                                               --
-- ---------------------------------------------------------------------------------------------- --

    A function that takes another function (or several functions) as an argument is called a
    higher-order function.

-- ---------------------------------------------------------------------------------------------- --
--  21) Cap_22.Modules                                                                            --
-- ---------------------------------------------------------------------------------------------- --
Haskell modules 2 are a useful way to group a set of related functionalities into a single 
package and manage different functions that may have the same names. 
The module definition is the first thing that goes in your Haskell file.
A basic module definition looks like: 

      module YourModule where

Note that:

    1. the name of the module begins with a capital letter;
    2. each file contains only one module.      

The name of the file is the name of the module plus the .hs file extension. 
Any dots '.' in the module name are changed for directories.

    - -------------------
    - Qualified imports
    - -------------------

So the module YourModule would be in the file YourModule.hs while a module Foo.Bar would 
be in the file Foo/Bar.hs or Foo\Bar.hs. 
Since the module name must begin with a capital letter, the file name must also start with 
a capital letter.    

import Data.Char (toLower, toUpper) -- import only the functions toLower and toUpper from Data.Char
import Data.List                    -- import everything exported from Data.List
import MyModule                     -- import everything exported from MyModule

Imported datatypes are specified by their name, followed by a list of imported constructors
in parenthesis. For example:

import Data.Tree (Tree(Node)) -- import only the Tree data type and its Node constructor 
                              -- from Data.Tree

What if you import some modules that have overlapping definitions? Or if you import a
module but want to overwrite a function yourself? 

There are three ways to handle these cases: 

    Qualified imports, hiding definitions, and renaming imports.

Qualified imports:

Say MyModule and MyOtherModule both have a definition for remove_e, which removes
all instances of e from a string. However, MyModule only removes lower-case e's, and
MyOtherModule removes both upper and lower case. In this case the following code is
ambiguous:

import MyModule
import MyOtherModule

-- someFunction puts a c in front of the text, and removes all e's from the rest

someFunction :: String -> String
someFunction text = 'c' : remove_e text

It isn't clear which remove_e is meant! To avoid this, use the qualified keyword:

import qualified MyModule
import qualified MyOtherModule

-- Will work, removes lower case e's
someFunction text = 'c' : MyModule.remove_e text 

 -- Will work, removes all e's
someOtherFunction text = 'c' : MyOtherModule.remove_e text

 -- Won't work as there is no remove_e defined
someIllegalFunction text = 'c' : remove_e text

In the latter code snippet, no function named remove_e is available at all. 
When we do qualified imports, all the imported values include the module names
as a prefix. 
Incidentally, you can also use the same prefixes even if you did a regular 
import (in our example, MyModule.remove_e works even if the "qualified" keyword 
isn't included).

    - -------------------
    - Hiding definitions
    - -------------------

Now suppose we want to import both MyModule and MyOtherModule, but we know for sure
we want to remove all e's, not just the lower cased ones. 
It will become really tedious to add MyOtherModule before every call to remove_e. 
Can't we just exclude the remove_e from MyModule?

import MyModule hiding (remove_e)
import MyOtherModule

someFunction text = 'c' : remove_e text

This works because of the word hiding on the import line. 
Whatever follows the "hiding" keyword will not be imported. 
Hide multiple items by listing them with parentheses and comma-separation:

import MyModule hiding (remove_e, remove_f)

Note that algebraic datatypes and type synonyms cannot be hidden. These are always
imported. If you have a datatype defined in multiple imported modules, you must use
qualified names.

    - -------------------
    - Renaming imports
    - -------------------

In this case, both the functions in MyModule and the functions in 
MyCompletelyDifferentModule can be prefixed with My:

import MyModule as My
import MyCompletelyDifferentModule as My

    - -------------------
    - Exporting
    - -------------------

How can we decide which functions are exported and which stay "internal"?

module MyModule (remove_e, add_two) where

add_one blah = blah + 1
remove_e text = filter (/= 'e') text
add_two blah = add_one . add_one $ blah

In this case, only remove_e and add_two are exported. 

While add_two is allowed to make use of add_one, functions in modules that
import MyModule cannot use add_one directly, as it isn't exported.

Datatype export specifications are written similarly to import. You name the type, and
follow with the list of constructors in parenthesis:

module MyModule2 (Tree(Branch, Leaf)) where

data Tree a = Branch {left, right :: Tree a}
| Leaf a


In this case, the module declaration could be rewritten "MyModule2 (Tree(..))", declaring
that all constructors are exported.

Maintaining an export list is good practice not only because it reduces namespace pollu-
tion but also because it enables certain compile-time optimizations 5 which are unavailable
otherwise.

-- ---------------------------------------------------------------------------------------------- --
-- 22) Cap_24.More_on_datatypes                                                                   --  
-- ---------------------------------------------------------------------------------------------- --

    - Enumerations
    - Named Fields (Record Syntax)
    - Parametrized_Types

-- ---------------------------------------------------------------------------------------------- --
-- 23) Cap_26.Classes_and_Types                                                                   --  
-- ---------------------------------------------------------------------------------------------- --    

    - Classes and types 
    - Classes and instances
    - Deriving
    - Class inheritance
    - Type constraints

-- ---------------------------------------------------------------------------------------------- --
-- 24) Cap_27.Functor_class                                                                       --
-- ---------------------------------------------------------------------------------------------- --

    - Introducing Functor

    Functor is a Prelude class for types which can be mapped over. It has a single method, called
    fmap.
    
    The class is defined as follows:

        class Functor f where
            fmap :: (a -> b) -> f a -> f b

    The usage of the type variable f can look a little strange at first. Here, f is a parametrized
    data type.

    Let's consider an instance of Functor: By replacing f with Maybe we get the following signature
    for fmap...
    
        fmap :: (a -> b) -> Maybe a -> Maybe b
        
    ... which fits the natural definition:

    instance Functor Maybe where
        fmap f Nothing = Nothing
        fmap f (Justx) = Just (f x)


    The Functor instance for lists (also in Prelude) is simple:
    
    instance Functor [] where 
        fmap = map
    
    ... and if we replace
    
    f with [] in the fmap signature, we get the familiar type of map.
    
    So, fmap is a generalization of map for any parametrized data type.

        map :: (a -> b) -> [a] -> [b]


    Naturally, we can provide Functor instances for our own data types.  
    In particular, treeMap can be promptly relocated to an instance:

    instance Functor Tree where
        fmap f (Leaf x) = Leaf (f x)
        fmap f (Branch left right) = Branch (fmap f left) (fmap f right)


    - The Functor Laws

        When providing a new instance of Functor, you should ensure it satisfies
        the two functor laws.    

        * The first law is:
            
            fmap id = id
        
        id is the identity function, which returns its argument unaltered. 
        The first law states that mapping id over a functorial value must
        return the functorial value unchanged.


        * Next, the second law:

            fmap (g . f) = fmap g . fmap f


        It states that it should not matter whether we map a composed 
        function or first map one function and then the other 
        (assuming the application order remains the same in both cases).



-- ---------------------------------------------------------------------------------------------- --
-- 25) Cap_29_PrologueIO_ApplicativeFunctor                                                       --
-- ---------------------------------------------------------------------------------------------- --

    - -------------------------
    - Applicative
    - -------------------------

    Main> :m +Text.Read
    Main Text.Read> 

    Main Text.Read> :t readMaybe
    
        readMaybe :: Read a => String -> Maybe a


    readMaybe provides a simple way of converting strings into Haskell values. 
    If the provided string has the correct format to be read as a value of type a, readMaybe
    gives back the converted value wrapped in Just; otherwise, the result is Nothing:

    To use readMaybe, we need to specify which type we are trying to read. Most of the time,
    that would be done through a combination of type inference and the signatures in our code. 

    Occasionally, however, it is more convenient to just slap in a type annotation rather than
    writing down a proper signature. For instance, 
    in the first example above the :: Maybe Integer in readMaybe "3" :: Maybe Integer
    says that the type of readMaybe  "3" is Maybe Integer.


    Main Text.Read> readMaybe "3" :: Maybe Integer
    Just 3

    Main Text.Read> readMaybe "hello" :: Maybe Integer
    Nothing

    - -------------------------
    - Application in functors
    - -------------------------
        - see code.

    - -------------------------
    - IO
    - -------------------------

        - getLine

        Main Text.Read> :t getLine
        getLine :: IO String        

        Using what we learned since then, we can now see that IO is a type constructor with one
        type variable, which happens to be instantiated as String in the case of getLine.

        That, however, doesn't get to the root of the issue: what does IO String really mean, and what
        is the difference between that and plain old String?

    - -------------------------
    - Referential transparency
    - -------------------------

    A key feature of Haskell is that all expressions we can write are 
    referentially transparent.

    That means we can replace any expression whatsoever by its value without
    changing the behaviour of the program. 
    For instance, consider this very simple program:

    addExclamation :: String-> String
    addExclamation s = s ++ "!"


    Given that addExclamation s = s ++ "!", we can rewrite main so that it doesn't mention
    addExclamation. All we have to do is replacing s by "Hello" in the right-hand side of 
    the addExclamation definition and then replacing addExclamation "Hello!" by the resulting
    expression. As advertised, the program behaviour does not change_

    test_addExclamation' = putStrLn ("Hello" ++ "!")
    test_addExclamation' 
    Hello!


    Now, suppose that the type of getLine were String. 
    In that case, we would be able to use it as the argument to addExclamation, as in:

    -- Not actual code.
    test_addExclamation'' = putStrLn (addExclamation getLine)

    In that case, however, a new question would spring forth: 
    if getLine is a String, which String is it? 
    
    There is no satisfactory answer: it could be "Hello", "Goodbye", or whatever else the 
    user chooses to type at the terminal. And yet, replacing getLine by any String breaks 
    the program, as the user would not be able to type the input string at the terminal any longer. 
    
    Therefore getLine having type String would cause referential transparency to be broken.

    As getLine illustrates, there is a fundamental indeterminacy associated with I/O actions. 
    
    Respecting this indeterminacy is necessary for preserving referential transparency.
    
    In Haskell, that is achieved through the IO type constructor.

    getLine being an IO String means that it is not any actual String, but both a placeholder 
    for a String that will only materialise when the program is executed and a promise that 
    this String will indeed be delivered (in the case of getLine, by slurping it from the terminal).

    If mx is a Maybe Double, then fmap (2*) mx doubles the value if it is there, and works regardless 
    of whether the value actually exists.
    
    Both Maybe a and IO a imply, for different reasons, a layer of indirection in reaching the 
    corresponding values of type a. 

    That being so, it comes as no surprise that, like Maybe, IO is a Functor, with fmap
    being the most elementary way of getting across the indirection.

    interactiveSumming :: IO()
    interactiveSumming = do
        putStrLn "Choose two numbers:"
        mx <- readMaybe <$> getLine  -- equivalently: fmap readMaybe getLine
        my <- readMaybe <$> getLine
        case (+) <$> mx <*> my :: Maybe Double of
            Just z  -> putStrLn ("The sum of your numbers is " ++ show z)
            Nothing -> do
                putStrLn "Invalid number. Retrying..."
                interactiveSumming

    
readMaybe <$> getLine can be read as "once getLine delivers a string, whatever it turns
out to be, apply readMaybe on it". 


-- fmap :: Functor f => (a -> b) -> f a -> f b
-- getLine :: IO String
-- readMaybe :: Read a => String -> Maybe a

--          a    ->   b          f a 
-- fmap ( String -> Maybe a) (IO String) -> (IO  String)




