
** ********************************************************************************************** **
**                                     Table of contents                                          **
** ********************************************************************************************** **

   1) Create VsCode project
   2) Show   VsCode preferences
   3) Set Vscode terminal
   4) Haskell Main
   5) Haskell Comments
   6) Cap_3_4 Variables_and_Functions
   7) Cap_5 Type Basics
   8) Cap_6 List and Tuples
   9) Cap_7 Type Basics II
  10) Cap_8 Building vocabulary
  11) Cap_9 Next Steps + Pattern Matching     
  12) Cap_10 Simple input and ouput
  13) Cap_12 Recursion
  14) Cap_13 More about Lists
  15) Cap_14 List Processing 
  16) Cap_15.Type_Declarations 
  17) Cap_16.Pattern_Matching   
  18) Cap_17.Control_Structures
  19) Cap_18.More_on_Functions 
  20) Cap_19.High_Order_Functions
  21) Cap_22.Modules
  22) Cap_24.More_on_datatypes
  23) Cap_26.Classes_and_Types
  24) Cap_27.Functor_class
  25) Cap_29.PrologueIO_ApplicativeFunctor
  26) Cap_29.PrologueIO_IO + Applicatives_tutorial
  27) Cap_30.Monads
  28) Cap_31.MaybeMonad
  29) Cap_32.ListMonad


-- ---------------------------------------------------------------------------------------------- --
--  1) Create VsCode project                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --

host@hskuser:~/dev/vscode.wks/haskell.learning/haskell.wikibooks$ stack new HaskellBasic new-template
Downloading template "new-template" to create project "HaskellBasic" in HaskellBasic/ ...

The following parameters were needed by the template but not provided: author-name
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-name: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-name:value"


The following parameters were needed by the template but not provided: author-email, author-name, category, copyright, github-username
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-email: value
    author-name: value
    category: value
    copyright: value
    github-username: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-email:value" -p "author-name:value" -p "category:value" -p "copyright:value" -p "github-username:value"

Looking for .cabal or package.yaml files to use to init the project.
Using cabal packages:

- HaskellBasic/

Selecting the best among 15 snapshots...

Downloaded lts-13.18 build plan.    
Didn't see Chart-1.9.1@sha256:cc50e1e65738ab2d6c30ae9e3f138962f87667d81f7860a0deeca9053f6d21ed,2857 in your package indices.
Updating and trying again.
Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/                                 
Downloading timestamp                                                                            
Downloading snapshot                                                                             
Updating index                                                                                   
Updated package index downloaded                                                                 
Update complete                                                                                  
Populated index cache.    
* Matches lts-13.18

Selected resolver: lts-13.18
Initialising configuration using resolver: lts-13.18
Total number of user packages considered: 1
Writing configuration to file: HaskellBasic/stack.yaml
All done.


-- ---------------------------------------------------------------------------------------------- --
-- 2) Show   VsCode preferences                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --

VsCode Preferences:
Creating User and Workspace Settings
To open your user and workspace settings, use the following VS Code menu command:

    On Windows/Linux - File > Preferences > Settings
    On macOS - Code > Preferences > Settings

You can also open the Settings editor from the Command Palette (Ctrl+Shift+P) with Preferences: Open Settings or use the keyboard shortcut (Ctrl+,).


-- ---------------------------------------------------------------------------------------------- --
--  3) Set Vscode terminal                                                                        -- 
-- ---------------------------------------------------------------------------------------------- --

export LC_ALL=en_US.UTF-8
ghci -isrc:app app/Main.hs
Prelude> :set prompt "\x03BB:"


-- ---------------------------------------------------------------------------------------------- --
-- 4) Haskell Main                                                                                -- 
-- ---------------------------------------------------------------------------------------------- --

module Main where

import Lib
import Cap_3.Variables_and_Functions

main :: IO ()
main = do

    putStrLn "haskell basic course ";    


-- ---------------------------------------------------------------------------------------------- --
-- 5) Haskell Comments                                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

-- single line comment
{--
     multi lines comment
--}

-- ---------------------------------------------------------------------------------------------- --
--  6) Cap_3_4 Variables_and_Functions                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Local definition
    - Prefix Infix operators
    - Boolean operations
    - Guards

-- ---------------------------------------------------------------------------------------------- --
--  7) Cap_5 Type Basics                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Haskell is STRONGLY TYPED

-- ---------------------------------------------------------------------------------------------- --
--  8) Cap_6 List and Tuples                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --    
    - List
    - Building a List
    - List of Lists
    - Tuples
    - Retrieve values
    - Tuples within Tuples
    - Polymorphic types

-- ---------------------------------------------------------------------------------------------- --
--  9) Cap_7 Type Basics II                                                                       -- 
-- ---------------------------------------------------------------------------------------------- --        
    - The Num class

-- ---------------------------------------------------------------------------------------------- --
--  10) Cap_8 Building vocabulary                                                                 -- 
-- ---------------------------------------------------------------------------------------------- --        
    - Function Composition:

        Function Composition is a really simply concept.
        It just means applying one function to a value and then applying another function to the
        result.

    - Prelude and hierarchical libraries:

        Prelude is the core library loaded by default in every Haskell program.

    Alongside with Prelude, there are the hierarchical libraries, which provide a much wider
    range of functionality.
    Although they are provided by default with GHC, they are not loaded automatically like
    Prelude.
    Rather they are distributed as modules, which must be imported into your program.

    ex.

    import Data.List


    For quick GHCi tests, just enter :m +Data.List at the command line to load that module.

    Prelude> :m +Data.List
    Prelude Data.List> :t permutations    
    permutations :: [a] -> a

    Resources:

    https://en.wikibooks.org/wiki/..%2FHierarchical%20libraries
    http://www.haskell.org/onlinereport/standard-prelude.html
    http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
    http://www.haskell.org/hoogle
    https://hackage.haskell.org/
    http://www.haskell.org/cabal/users-guide/
    http://holumbus.fh-wedel.de/hayoo/hayoo.html


-- ---------------------------------------------------------------------------------------------- --
--  11) Cap_9 Next Steps                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --       

    - if/then/else
    - if/then/else by Guards
    - Pattern Matching
    - Tuples and Lists Pattern
    - let bindings

-- ---------------------------------------------------------------------------------------------- --
--  12) Cap_10 Simple input and ouput                                                             -- 
-- ---------------------------------------------------------------------------------------------- --       

    -- ----------------------
    -- Back to the real world
    -- ----------------------
    
      Prelude> putStrLn "Hello, World!"

    putStrLn is one of the standard Prelude tools. As the "putStr" part of the name suggests,
    it takes a String as an argument and prints it to the screen. We could use putStr on its
    own, but we usually include the ”Ln” part so to also print a line break. Thus, whatever else
    is printed next will appear on a new line.

    So now you should be thinking, "what is the type of the putStrLn function?" 
      
    It takes a String and gives... um... what? What do we call that? 
      
    The program doesn't get something back that it can use in another function. 
      
    Instead, the result involves having the computer change the screen. 
    In other words, it does something in the world outside of the program.

    What type could that have? Let's see what GHCi tells us:

        Prelude> :t putStrLn
        putStrLn :: String -> IO ()

    "IO" stands for "input and output"

    Wherever there is IO in a type, interaction with the world outside the program is involved.
    We'll call these IO values actions. 
      
    The other part of the IO type, in this case (), is the type of the return value of the action;
    that is, the type of what it gives back to the program (as opposed to what it does outside 
    the program). 
      
      () (pronounced as ”unit”) is a type that only contains one value also called () 
         (effectively a tuple with zero elements).

    Since putStrLn sends output to the world but doesn't return
    anything to the program, () is used as a placeholder. We might read IO () as 
    "action which returns ()".    

    A few more examples of when we use IO:
    
    - print a string to the screen
    - read a string from a keyboard
    - write data to a file
    - read data from a file

    A complete Haskell program is actually a big IO action. In a compiled program, this action 
    is called main and has type IO (). From this point of view, to write a Haskell program is 
    to combine actions and functions to form the overall action main that will be executed when 
    the program is run. The compiler takes care of instructing the computer on how to do this.    

    -- ----------------------
    -- do notation
    -- ----------------------

    do notation provides a convenient means of putting actions together (which is essential in
    doing useful things with Haskell).

-- ---------------------------------------------------------------------------------------------- --
--  13) Cap_12 Recursion                                                                          -- 
-- ---------------------------------------------------------------------------------------------- -- 

    - Recursion:
       Recursion is the idea of defining a function in terms of itself.

    - List based Recursion 

-- ---------------------------------------------------------------------------------------------- --
--  14) Cap_13 More about Lists                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --           

    - map function
    - Dot Dot Notation
    - Infinite Lists
    - Prelude null fuction
    

-- ---------------------------------------------------------------------------------------------- --
--  15) Cap_14 List Processing                                                                    -- 
-- ---------------------------------------------------------------------------------------------- --      

    - Folds 
        - foldr
        - foldl
        - scans
        - filter
        - List comprehensions

-- ---------------------------------------------------------------------------------------------- --
--  16) Cap_15.Type_Declarations                                                                  -- 
-- ---------------------------------------------------------------------------------------------- --      

    You're not restricted to working with just the types provided by default with the language.
    
    Haskell has three basic ways to declare a new type:

    - The data declaration, which defines new data types.
    - The type declaration for type synonyms, that is, alternative names for existing types.
    - The newtype declaration, which defines new data types equivalent to existing ones.

    - data and constructor functions
    - deconstructing types
    - type for making type synonyms

-- ---------------------------------------------------------------------------------------------- --
--  17) Cap_16.Pattern_Matching                                                                   --
-- ---------------------------------------------------------------------------------------------- --

    - Pattern Matching

    Some languages like Perl and Python use term pattern matching for matching regular expression
    against strings.
    The pattern matching we are referring to in this chapter is something completely different.
    Here pattern matching is used to deconstruct values according  to their type specification.

    - Tuple constructors
    - Matching literal values

    - Syntax_Tricks
        - As-patterns

-- ---------------------------------------------------------------------------------------------- --
--  18) Cap_17.Control_Structures                                                                 --
-- ---------------------------------------------------------------------------------------------- --
    - if and guards revisited
    - Embedding if expressions
    - case expressions
    - Controlling actions, revisited

-- ---------------------------------------------------------------------------------------------- --
--  19) Cap_18.More_on_Functions                                                                  --
-- ---------------------------------------------------------------------------------------------- --

    - let and where:

        As discussed in earlier chapters, let and where are useful in local function definitions. 
        Here, sumStr calls addStr function:

    - Anonymous_Functions - lambdas
    - Operators

-- ---------------------------------------------------------------------------------------------- --
--  20) Cap_19.High_Order_Functions                                                               --
-- ---------------------------------------------------------------------------------------------- --

    A function that takes another function (or several functions) as an argument is called a
    higher-order function.

-- ---------------------------------------------------------------------------------------------- --
--  21) Cap_22.Modules                                                                            --
-- ---------------------------------------------------------------------------------------------- --
Haskell modules 2 are a useful way to group a set of related functionalities into a single 
package and manage different functions that may have the same names. 
The module definition is the first thing that goes in your Haskell file.
A basic module definition looks like: 

      module YourModule where

Note that:

    1. the name of the module begins with a capital letter;
    2. each file contains only one module.      

The name of the file is the name of the module plus the .hs file extension. 
Any dots '.' in the module name are changed for directories.

    - -------------------
    - Qualified imports
    - -------------------

So the module YourModule would be in the file YourModule.hs while a module Foo.Bar would 
be in the file Foo/Bar.hs or Foo\Bar.hs. 
Since the module name must begin with a capital letter, the file name must also start with 
a capital letter.    

import Data.Char (toLower, toUpper) -- import only the functions toLower and toUpper from Data.Char
import Data.List                    -- import everything exported from Data.List
import MyModule                     -- import everything exported from MyModule

Imported datatypes are specified by their name, followed by a list of imported constructors
in parenthesis. For example:

import Data.Tree (Tree(Node)) -- import only the Tree data type and its Node constructor 
                              -- from Data.Tree

What if you import some modules that have overlapping definitions? Or if you import a
module but want to overwrite a function yourself? 

There are three ways to handle these cases: 

    Qualified imports, hiding definitions, and renaming imports.

Qualified imports:

Say MyModule and MyOtherModule both have a definition for remove_e, which removes
all instances of e from a string. However, MyModule only removes lower-case e's, and
MyOtherModule removes both upper and lower case. In this case the following code is
ambiguous:

import MyModule
import MyOtherModule

-- someFunction puts a c in front of the text, and removes all e's from the rest

someFunction :: String -> String
someFunction text = 'c' : remove_e text

It isn't clear which remove_e is meant! To avoid this, use the qualified keyword:

import qualified MyModule
import qualified MyOtherModule

-- Will work, removes lower case e's
someFunction text = 'c' : MyModule.remove_e text 

 -- Will work, removes all e's
someOtherFunction text = 'c' : MyOtherModule.remove_e text

 -- Won't work as there is no remove_e defined
someIllegalFunction text = 'c' : remove_e text

In the latter code snippet, no function named remove_e is available at all. 
When we do qualified imports, all the imported values include the module names
as a prefix. 
Incidentally, you can also use the same prefixes even if you did a regular 
import (in our example, MyModule.remove_e works even if the "qualified" keyword 
isn't included).

    - -------------------
    - Hiding definitions
    - -------------------

Now suppose we want to import both MyModule and MyOtherModule, but we know for sure
we want to remove all e's, not just the lower cased ones. 
It will become really tedious to add MyOtherModule before every call to remove_e. 
Can't we just exclude the remove_e from MyModule?

import MyModule hiding (remove_e)
import MyOtherModule

someFunction text = 'c' : remove_e text

This works because of the word hiding on the import line. 
Whatever follows the "hiding" keyword will not be imported. 
Hide multiple items by listing them with parentheses and comma-separation:

import MyModule hiding (remove_e, remove_f)

Note that algebraic datatypes and type synonyms cannot be hidden. These are always
imported. If you have a datatype defined in multiple imported modules, you must use
qualified names.

    - -------------------
    - Renaming imports
    - -------------------

In this case, both the functions in MyModule and the functions in 
MyCompletelyDifferentModule can be prefixed with My:

import MyModule as My
import MyCompletelyDifferentModule as My

    - -------------------
    - Exporting
    - -------------------

How can we decide which functions are exported and which stay "internal"?

module MyModule (remove_e, add_two) where

add_one blah = blah + 1
remove_e text = filter (/= 'e') text
add_two blah = add_one . add_one $ blah

In this case, only remove_e and add_two are exported. 

While add_two is allowed to make use of add_one, functions in modules that
import MyModule cannot use add_one directly, as it isn't exported.

Datatype export specifications are written similarly to import. You name the type, and
follow with the list of constructors in parenthesis:

module MyModule2 (Tree(Branch, Leaf)) where

data Tree a = Branch {left, right :: Tree a}
| Leaf a


In this case, the module declaration could be rewritten "MyModule2 (Tree(..))", declaring
that all constructors are exported.

Maintaining an export list is good practice not only because it reduces namespace pollu-
tion but also because it enables certain compile-time optimizations 5 which are unavailable
otherwise.

-- ---------------------------------------------------------------------------------------------- --
-- 22) Cap_24.More_on_datatypes                                                                   --  
-- ---------------------------------------------------------------------------------------------- --

    - Enumerations
    - Named Fields (Record Syntax)
    - Parametrized_Types

-- ---------------------------------------------------------------------------------------------- --
-- 23) Cap_26.Classes_and_Types                                                                   --  
-- ---------------------------------------------------------------------------------------------- --    

    - Classes and types 
    - Classes and instances
    - Deriving
    - Class inheritance
    - Type constraints

-- ---------------------------------------------------------------------------------------------- --
-- 24) Cap_27.Functor_class                                                                       --
-- ---------------------------------------------------------------------------------------------- --

    - Introducing Functor

    Functor is a Prelude class for types which can be mapped over. It has a single method, called
    fmap.
    
    The class is defined as follows:

        class Functor f where
            fmap :: (a -> b) -> f a -> f b

    The usage of the type variable f can look a little strange at first. Here, f is a parametrized
    data type.

    Let's consider an instance of Functor: By replacing f with Maybe we get the following signature
    for fmap...
    
        fmap :: (a -> b) -> Maybe a -> Maybe b
        
    ... which fits the natural definition:

    instance Functor Maybe where
        fmap f Nothing = Nothing
        fmap f (Justx) = Just (f x)


    The Functor instance for lists (also in Prelude) is simple:
    
    instance Functor [] where 
        fmap = map
    
    ... and if we replace
    
    f with [] in the fmap signature, we get the familiar type of map.
    
    So, fmap is a generalization of map for any parametrized data type.

        map :: (a -> b) -> [a] -> [b]


    Naturally, we can provide Functor instances for our own data types.  
    In particular, treeMap can be promptly relocated to an instance:

    instance Functor Tree where
        fmap f (Leaf x) = Leaf (f x)
        fmap f (Branch left right) = Branch (fmap f left) (fmap f right)


    - The Functor Laws

        When providing a new instance of Functor, you should ensure it satisfies
        the two functor laws.    

        * The first law is:
            
            fmap id = id
        
        id is the identity function, which returns its argument unaltered. 
        The first law states that mapping id over a functorial value must
        return the functorial value unchanged.


        * Next, the second law:

            fmap (g . f) = fmap g . fmap f


        It states that it should not matter whether we map a composed 
        function or first map one function and then the other 
        (assuming the application order remains the same in both cases).



-- ---------------------------------------------------------------------------------------------- --
-- 25) Cap_29.PrologueIO_ApplicativeFunctor                                                       --
-- ---------------------------------------------------------------------------------------------- --

    - -------------------------
    - Applicative
    - -------------------------

    Main> :m +Text.Read
    Main Text.Read> 

    Main Text.Read> :t readMaybe
    
        readMaybe :: Read a => String -> Maybe a


    readMaybe provides a simple way of converting strings into Haskell values. 
    If the provided string has the correct format to be read as a value of type a, readMaybe
    gives back the converted value wrapped in Just; otherwise, the result is Nothing:

    To use readMaybe, we need to specify which type we are trying to read. Most of the time,
    that would be done through a combination of type inference and the signatures in our code. 

    Occasionally, however, it is more convenient to just slap in a type annotation rather than
    writing down a proper signature. For instance, 
    in the first example above the :: Maybe Integer in readMaybe "3" :: Maybe Integer
    says that the type of readMaybe  "3" is Maybe Integer.


    Main Text.Read> readMaybe "3" :: Maybe Integer
    Just 3

    Main Text.Read> readMaybe "hello" :: Maybe Integer
    Nothing

    - -------------------------
    - Application in functors
    - -------------------------
        - see code.

    - -------------------------
    - IO
    - -------------------------

        - getLine

        Main Text.Read> :t getLine
        getLine :: IO String        

        Using what we learned since then, we can now see that IO is a type constructor with one
        type variable, which happens to be instantiated as String in the case of getLine.

        That, however, doesn't get to the root of the issue: what does IO String really mean, and what
        is the difference between that and plain old String?

    - -------------------------
    - Referential transparency
    - -------------------------

    A key feature of Haskell is that all expressions we can write are 
    referentially transparent.

    That means we can replace any expression whatsoever by its value without
    changing the behaviour of the program. 
    For instance, consider this very simple program:

    addExclamation :: String-> String
    addExclamation s = s ++ "!"


    Given that addExclamation s = s ++ "!", we can rewrite main so that it doesn't mention
    addExclamation. All we have to do is replacing s by "Hello" in the right-hand side of 
    the addExclamation definition and then replacing addExclamation "Hello!" by the resulting
    expression. As advertised, the program behaviour does not change_

    test_addExclamation' = putStrLn ("Hello" ++ "!")
    test_addExclamation' 
    Hello!


    Now, suppose that the type of getLine were String. 
    In that case, we would be able to use it as the argument to addExclamation, as in:

    -- Not actual code.
    test_addExclamation'' = putStrLn (addExclamation getLine)

    In that case, however, a new question would spring forth: 
    if getLine is a String, which String is it? 
    
    There is no satisfactory answer: it could be "Hello", "Goodbye", or whatever else the 
    user chooses to type at the terminal. And yet, replacing getLine by any String breaks 
    the program, as the user would not be able to type the input string at the terminal any longer. 
    
    Therefore getLine having type String would cause referential transparency to be broken.

    As getLine illustrates, there is a fundamental indeterminacy associated with I/O actions. 
    
    Respecting this indeterminacy is necessary for preserving referential transparency.
    
    In Haskell, that is achieved through the IO type constructor.

    getLine being an IO String means that it is not any actual String, but both a placeholder 
    for a String that will only materialise when the program is executed and a promise that 
    this String will indeed be delivered (in the case of getLine, by slurping it from the terminal).

    If mx is a Maybe Double, then fmap (2*) mx doubles the value if it is there, and works regardless 
    of whether the value actually exists.
    
    Both Maybe a and IO a imply, for different reasons, a layer of indirection in reaching the 
    corresponding values of type a. 

    That being so, it comes as no surprise that, like Maybe, IO is a Functor, with fmap
    being the most elementary way of getting across the indirection.

    interactiveSumming :: IO()
    interactiveSumming = do
        putStrLn "Choose two numbers:"
        mx <- readMaybe <$> getLine  -- equivalently: fmap readMaybe getLine
        my <- readMaybe <$> getLine
        case (+) <$> mx <*> my :: Maybe Double of
            Just z  -> putStrLn ("The sum of your numbers is " ++ show z)
            Nothing -> do
                putStrLn "Invalid number. Retrying..."
                interactiveSumming

    
readMaybe <$> getLine can be read as "once getLine delivers a string, whatever it turns
out to be, apply readMaybe on it". 


-- fmap :: Functor f => (a -> b) -> f a -> f b
-- getLine :: IO String
-- readMaybe :: Read a => String -> Maybe a

--          a    ->   b          f a 
-- fmap ( String -> Maybe a) (IO String) -> (IO  String)

-- ---------------------------------------------------------------------------------------------- --
-- 26) Cap_29.PrologueIO_IO + Applicatives_tutorial                                               --
-- ---------------------------------------------------------------------------------------------- --

        - <$>
        - <*>
-- ---------------------------------------------------------------------------------------------- --
-- 27) Cap_30.Monads                                                                              --
-- ---------------------------------------------------------------------------------------------- --

    - -------------------------
    - Monads:
    - -------------------------

    Historically, monads were introduced into Haskell to perform input and output – that is,
    I/O operations of the sort we dealt with in the Simple input and output.
    A predetermined execution order is crucial for things like reading and writing files, 
    and monadic operations lend themselves naturally to sequencing. 
    However, monads are by no means limited to input and output.

    They can be used to provide a whole range of features, such as exceptions, state, non-determinism, 
    continuations, coroutines, and more.

    - -------------------------
    - Definition:
    - -------------------------

        A monad is defined by three things:

        * a type constructor m;
        * a function return;
        * an operator (>>=) which is pronounced "bind".

    The function and operator are methods of the Monad type class and have types.

    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b

    and are required to obey three laws that will be explained later on.    

    For a concrete example, take the Maybe monad. 
    
    The type constructor is:

     m = Maybe
     
     while return and (>>=) are defined like this:

    return :: a -> Maybe a
    return x  = Just x
    
    (>>=)  :: Maybe a -> (a -> Maybe b) -> Maybe b
    m >>= g = case m of
                Nothing -> Nothing
                Justx   -> g x


    Maybe is the monad, and return brings a value into it by wrapping it with Just. 
    As for (>>=) , it takes a m :: Maybe a value and a g :: a -> Maybe b function. 
    If m is Nothing, there is nothing to do and the result is Nothing. 
    Otherwise, in the Just x case, g is applied to x, the underlying value wrapped 
    in Just, to give a Maybe b result. 
    
    Note that this result may or may not beNothing , depending on what g does to. 
    
    To sum it all up, if there is an underlying value of type a in m , we apply g to it, 
    which brings the underlying value back into the Maybe monad.


    - -------------------------
    - Motivation: Maybe
    - -------------------------
    To see the usefulness of (>>=) and the Maybe monad, consider the following example: 
    Imagine a family database that provides two functions:

    father :: Person -> Maybe Person
    mother :: Person -> Maybe Person

    Let's combine our functions to query various grandparents. 
    For instance, the following function looks up the maternal grandfather (the father of one's mother):

    maternalGrandfather :: Person -> Maybe Person
    maternalGrandfather p = case mother p of
                                Nothing  -> Nothing
                                Just mom -> father mom


    Or consider a function that checks whether both grandfathers are in the database:

    bothGrandfathers :: Person -> Maybe (Person, Person)
    bothGrandfathers p =
        case father p of
            Nothing -> Nothing
            Just dad ->
                case father dad of
                    Nothing -> Nothing
                    Just gf1 ->                          -- found first grandfather
                        case mother p of
                            Nothing -> Nothing
                            Just mom ->
                                case father mom of
                                    Nothing -> Nothing
                                    Just gf2 ->          -- found second grandfather
                                        Just (gf1, gf2)

    Every single query might fail by returning Nothingand the whole function must fail 
    with Nothing if that happens.

    Clearly there has to be a better way to write that instead of repeating the case of
    Nothing again and again! Indeed, that's what the Maybe monad is set out to do. 
    With the help of lambda expressions and return , we can rewrite the two grandfathers
    function as well:

    bothGrandfathers' p =
       father p >>=
           (\dad -> father dad >>=
               (\gf1 -> mother p >>=             -- gf1 is only used in the final return
                   (\mom -> father mom >>=
                       (\gf2 -> return (gf1,gf2) ))))


    While these nested lambda expressions may look confusing to you, the thing to take away
    here is that (>>=) releases us from listing all the Nothing s, shifting the focus back 
    to the interesting part of the code.

    To be a little more precise: The result of father p is a monadic value 
    (in this case, either Just dad or Nothing , depending on whether p's father is in the database). 
    As the father function takes a regular (non-monadic value), the (>>=) feeds p's dad to it as a
    non-monadic value. The result of father dad is then monadic again, and the process continues.

    So, (>>=) helps us pass non-monadic values to functions without actually leaving a monad.
    In the case of the Maybe monad, the monadic aspect is the qualifier that we don't know
    with certainty whether the value will be found.


    - -------------------------
    - Type Class
    - -------------------------

    In Haskell, the Monad type class is used to implement monads. 
    It is provided by the Control.Monad module and included in the Prelude. 
    
    The class has the following methods:
    
    class Applicative m => Monad m where
        return :: a      -> m a
        (>>=)  :: m a    -> (a -> m b) -> m b
        (>>)   :: m a    -> m b -> m b
        fail   :: String -> m a


    Aside from return and bind, there are two additional methods, (>>) and fail. 
    Both of them have default implementations, and so you don't need to provide 
    them when writing an instance.

    The operator (>>), spelled "then", is a mere convenience and has the default 
    implementation:

    m >> n = m >>= \_ -> n


    (>>) sequences two monadic actions when the second action does not involve the
    result of the first, which is a common scenario for monads such as IO.


    printSomethingTwice :: String -> IO ()
    printSomethingTwice str = putStrLn str >> putStrLn str

    The function fail handles pattern match failures in do notation. 
    It's an unfortunate technical necessity and doesn't really have 
    anything to do with monads. 
    You are advised not to call fail directly in your code!!


    - -------------------------
    - Monad and Applicative
    - -------------------------

    An important thing to note is that Applicative is a superclass of Monad. 
    
    * First of all, every Monad is also a Functor and an Applicative, and so fmap, 
      pure, (<*>) can all be used with monads. 
    
    * Secondly, actually writing a Monad instance also requires providing Functor 
      and Applicative instances. 
      
    * Thirdly, if you have worked through the Prologue, the types and roles of 
      return and (>>) should look familiar.


    (*>)   :: Applicative f => f a -> f b -> f b
    (>>)   :: Monad m => m a -> m b -> m b
    pure   :: Applicative f => a -> f a
    return :: Monad m => a -> m a


    The only difference between the types of (*>) and (>>) is that the constraint 
    changes from Applicative to Monad. 
    
    In fact, that is the only difference between the methods: 
    
    if you are dealing with a Monad you can always replace (*>) and (>>), and vice-versa. 
    The same goes for pure/return – in fact, it is not even necessary to implement return 
    if there is an independent definition of pure in the Applicative instance, 
    as return = pure is provided as a default definition of return.


    - -------------------------
    - Notions of Computation
    - -------------------------

    We have seen how (>>=) and return are very handy for removing boilerplate code that
    crops up when using Maybe. That, however, is not enough to justify why monads matter 
    so much. 
    
    Our next step towards that will be rewriting the two-grandfathers function in a quite
    different-looking style: 
    
    Using do notation with explicit braces and semicolons. 
    Depending on your experience with other programming languages, you may find this very suggestive:

    bothGrandfathers p = do {
        dad <- father p;
        gf1 <- father dad;
        mom <- mother p;
        gf2 <- father mom;
        return (gf1, gf2);
    }


    If this looks like a code snippet in an imperative programming language to you, that's
    because it is. 
    
    In particular, this imperative language supports exceptions : father and mother are 
    functions that might fail to produce results, raising an exception instead; and when that
    happens, the whole do-block will fail, i.e. terminate with an exception (meaning,
    evaluate to Nothing, here).

    In other words, the expression father p, which has type Maybe Person, is interpreted as
    a statement in an imperative language that returns a Person as the result, or fails.

    This is true for all monads: a value of type M a is interpreted as a statement in an 
    imperative language M that returns a value of type a as its result; and the semantics of 
    this language are determined by the monad M.
    
    Under this interpretation, the then operator (>>) is simply an implementation of the
    semicolon, and (>>=) of the semicolon and assignment (binding) of the result of a
    previous computational step. 
    

    Different semantics of the imperative language correspond to different monads. 
    The following table shows the classic selection that every Haskell programmer should know. 
    If the idea behind monads is still unclear to you, studying each of the examples in the 
    following chapters will not only give you a well-rounded toolbox but also help you understand
    the common abstraction behind them.

    ====================================================================================
    |       Monad       |  Imperative Semantics                                        |
    ====================================================================================
    |       Maybe       |  Exception                                                   |
     ----------------------------------------------------------------------------------
    |       Error       |  Exception                                                   |
     ----------------------------------------------------------------------------------
    |       State       |  Global state                                                |
     ----------------------------------------------------------------------------------
    |       IO          |  Input/Output                                                |
     ----------------------------------------------------------------------------------
    |    [] (lists)     |  Nondeterminism                                              |
     ----------------------------------------------------------------------------------
    |       Reader      |  Environment                                                 |
     ----------------------------------------------------------------------------------
    |       Writer      |  Logger                                                      |
     ----------------------------------------------------------------------------------


    - -------------------------
    - Monad Laws:
    - -------------------------

    In Haskell, every instance of the Monad type class (and thus all implementations of bind
    (>>=) and return) must obey the following three laws:    


    m >>= return    = m                         -- right unit
    return x >>= f  = f x                       -- left unit
    (m >>= f) >>= g = m >>= (\x -> f x >>= g)   -- associativity


    * Return as neutral element    

    The behavior of return is specified by the left and right unit laws. 
    They state that return doesn't perform any computation, it just collects values. 
    For instance:

    maternalGrandfather p = do
            mom <- mother p
            gf <- father mom
            return gf

    is exactly the same as

    maternalGrandfather p = do
            mom <- mother p
            father mom


    * Associativity of bind


    The law of associativity makes sure that (like the semicolon) the bind operator (>>=) 
    only cares about the order of computations, not about their nesting; 
    e.g. we could have written bothGrandfathers like this (compare with our earliest 
    version without do):

    bothGrandfathers p =
        (father p >>= father) >>=
            (\gf1 -> (mother p >>= father) >>=
                (\gf2 -> return (gf1,gf2) ))


    The associativity of the then operator (>>) is a special case:
    
    (m >> n) >> o = m >> (n >> o)


    - ----------------------------
    - Monads and Category Theory
    - ----------------------------

    The definition of monads in Category Theory actually uses a slightly different presentation. 
    Translated into Haskell, this presentation gives an alternative yet equivalent definition of
    a monad which can give us some additional insight.
    
    So far, we have defined monads in terms of (>>=) and return. 
    
    
    The alternative definition, instead, treats monads as functors with two additional combinators:

    fmap    :: (a -> b) -> M a -> M b   -- functor
    return  :: a -> M a
    join    :: M (M a) -> M a


    For the purposes of this discussion, we will use the functors-as-containers metaphor discussed
    in the chapter on the functor class. 
    
    According to it, a functor M can be thought of as container, so that M a "contains" values of 
    type a, with a corresponding mapping function, i.e. fmap, that allows functions to be applied to 
    values inside it.

    Under this interpretation, the functions behave as follows:

        * fmap applies a given function to every element in a container
        * return packages an element into a container,
        * join takes a container of containers and flattens it into a single container.


     With these functions, the bind combinator can be defined as follows:


        m >>= g = join (fmap g m)    


    Likewise, we could give a definition of fmap and join in terms of (>>=) and return:


    map f x = x >>= (return . f)
    join x  = x >>= id

-- ---------------------------------------------------------------------------------------------- --
--  28) Maybe Monad                                                                               -- 
-- ---------------------------------------------------------------------------------------------- --


    The Maybe monad represents computations which might "go wrong" by not returning a value. 
    For reference, here are the definitions of return and (>>=) for Maybe as we saw in the 
    last chapter: 
    
    return :: a -> Maybe a
    return x = Just x

    (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
    (>>=) m g = case m of
                    Nothing -> Nothing
                    Just x -> g x





    - ----------------------------
    - Safe functions
    - ----------------------------

    The Maybe datatype provides a way to make a safety wrapper around partial functions,
    that is, functions which can fail to work for a range of arguments. 
    
    For example, head and tail only work with non-empty lists. 
    
    Another typical case, which we will explore in this section, are mathematical functions
    like sqrt and log; (as far as real numbers are concerned) these are only defined for 
    non-negative arguments.


    > log 1000
    6.907755278982137

    > log (-1000)
    ''ERROR'' -- runtime error

    To avoid this crash, a ”safe” implementation of log could be:

    safeLog :: (Floating a, Ord a) => a -> Maybe a
    safeLog x
        | x > 0 = Just (log x)
        | otherwise = Nothing
    
    > safeLog 1000
    Just 6.907755278982137

    > safeLog -1000
    Nothing


-- ---------------------------------------------------------------------------------------------- --
--  29) List Monad                                                                                -- 
-- ---------------------------------------------------------------------------------------------- --

    As monads, lists are used to model nondeterministic computations which may return an arbitrary 
    number of results. 

    There is a certain parallel with how Maybe represented  computations which could return zero or 
    one value; but with lists, we can return zero, one, or many values (the number of values being 
    reflected in the length of the list).


    - ----------------------------
    - The Monad instance of lists
    - ----------------------------

    The return function for lists simply injects a value into a list:
    
        return x = [x]

    The type of the list return is return :: a -> [a], or, equivalently, return :: a -> [] a. 
    
    The latter style of writing it makes it more obvious that we are replacing the generic type 
    constructor in the signature of return (which we had called M in Understanding monads ) by 
    the list type constructor [] (which is distinct from but easy to confuse with the empty list!).

    The binding operator is less trivial. We will begin by considering its type, which for the
    case of lists should be:

    [a] -> (a -> [b]) -> [b]

    The actual process here involves first mapping a given function over a given list to get back a 
    list of lists, i.e. type [[b]] (of course, many functions which you might use in mapping do not 
    return lists; but, as shown in the type signature above, monadic binding for lists only works 
    with functions that return lists). To get back to a regular list, we then concatenate the elements 
    of our list of lists to get a final result of type [b]. Thus, we can define the list version of (>>=):
        
        xs >>= f = concat (map f xs)

    The bind operator is key to understanding how different monads do their jobs, as its definition specifies
    the chaining strategy used when working with the monad.
    
    In the case of the list monad, the strategy allows us to model non-determinism: 
    
        an a -> [b] function

    can be seen as a way of generating, from an input of type a, an unspecified number of
    possible outputs of type b, without settling on any one of them in particular. 
    
    (>>=), from that perspective, does that for multiple inputs and combines all output 
    possibilities in a single result list. 

    
















