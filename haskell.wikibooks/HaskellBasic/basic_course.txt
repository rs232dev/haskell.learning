

** ********************************************************************************************** **
**                                     Table of contents                                          **
** ********************************************************************************************** **

   1) Create VsCode project
   2) Show   VsCode preferences
   3) Set Vscode terminal
   4) Haskell Main
   5) Haskell Comments
   6) Cap_3_4 Variables_and_Functions
   7) Cap_5 Type Basics
   8) Cap_6 List and Tuples
   9) Cap_7 Type Basics II
  10) Cap_8 Building vocabulary
  11) Cap_9 Next Steps + Pattern Matching     
  12) Cap_10 Simple input and ouput
  13) Cap_12 Recursion
  14) Cap_13 More about Lists
  15) Cap_14 List Processing 
  16) Cap_15.Type_Declarations 
  17) Cap_16.Pattern_Matching   
  18) Cap_17.Control_Structures
  19) Cap_18.More_on_Functions 
  20) Cap_19.High_Order_Functions
  21) Cap_22.Modules
  22) Cap_24.More_on_datatypes
  23) Cap_26.Classes_and_Types


-- ---------------------------------------------------------------------------------------------- --
--  1) Create VsCode project                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --

host@hskuser:~/dev/vscode.wks/haskell.learning/haskell.wikibooks$ stack new HaskellBasic new-template
Downloading template "new-template" to create project "HaskellBasic" in HaskellBasic/ ...

The following parameters were needed by the template but not provided: author-name
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-name: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-name:value"


The following parameters were needed by the template but not provided: author-email, author-name, category, copyright, github-username
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-email: value
    author-name: value
    category: value
    copyright: value
    github-username: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-email:value" -p "author-name:value" -p "category:value" -p "copyright:value" -p "github-username:value"

Looking for .cabal or package.yaml files to use to init the project.
Using cabal packages:

- HaskellBasic/

Selecting the best among 15 snapshots...

Downloaded lts-13.18 build plan.    
Didn't see Chart-1.9.1@sha256:cc50e1e65738ab2d6c30ae9e3f138962f87667d81f7860a0deeca9053f6d21ed,2857 in your package indices.
Updating and trying again.
Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/                                 
Downloading timestamp                                                                            
Downloading snapshot                                                                             
Updating index                                                                                   
Updated package index downloaded                                                                 
Update complete                                                                                  
Populated index cache.    
* Matches lts-13.18

Selected resolver: lts-13.18
Initialising configuration using resolver: lts-13.18
Total number of user packages considered: 1
Writing configuration to file: HaskellBasic/stack.yaml
All done.


-- ---------------------------------------------------------------------------------------------- --
-- 2) Show   VsCode preferences                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --

VsCode Preferences:
Creating User and Workspace Settings
To open your user and workspace settings, use the following VS Code menu command:

    On Windows/Linux - File > Preferences > Settings
    On macOS - Code > Preferences > Settings

You can also open the Settings editor from the Command Palette (Ctrl+Shift+P) with Preferences: Open Settings or use the keyboard shortcut (Ctrl+,).


-- ---------------------------------------------------------------------------------------------- --
--  3) Set Vscode terminal                                                                        -- 
-- ---------------------------------------------------------------------------------------------- --

export LC_ALL=en_US.UTF-8
ghci -isrc:app app/Main.hs
Prelude> :set prompt "\x03BB:"


-- ---------------------------------------------------------------------------------------------- --
-- 4) Haskell Main                                                                                -- 
-- ---------------------------------------------------------------------------------------------- --

module Main where

import Lib
import Cap_3.Variables_and_Functions

main :: IO ()
main = do

    putStrLn "haskell basic course ";    


-- ---------------------------------------------------------------------------------------------- --
-- 5) Haskell Comments                                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

-- single line comment
{--
     multi lines comment
--}

-- ---------------------------------------------------------------------------------------------- --
--  6) Cap_3_4 Variables_and_Functions                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Local definition
    - Prefix Infix operators
    - Boolean operations
    - Guards

-- ---------------------------------------------------------------------------------------------- --
--  7) Cap_5 Type Basics                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Haskell is STRONGLY TYPED

-- ---------------------------------------------------------------------------------------------- --
--  8) Cap_6 List and Tuples                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --    
    - List
    - Building a List
    - List of Lists
    - Tuples
    - Retrieve values
    - Tuples within Tuples
    - Polymorphic types

-- ---------------------------------------------------------------------------------------------- --
--  9) Cap_7 Type Basics II                                                                       -- 
-- ---------------------------------------------------------------------------------------------- --        
    - The Num class

-- ---------------------------------------------------------------------------------------------- --
--  10) Cap_8 Building vocabulary                                                                 -- 
-- ---------------------------------------------------------------------------------------------- --        
    - Function Composition:

        Function Composition is a really simply concept.
        It just means applying one function to a value and then applying another function to the
        result.

    - Prelude and hierarchical libraries:

        Prelude is the core library loaded by default in every Haskell program.

    Alongside with Prelude, there are the hierarchical libraries, which provide a much wider
    range of functionality.
    Although they are provided by default with GHC, they are not loaded automatically like
    Prelude.
    Rather they are distributed as modules, which must be imported into your program.

    ex.

    import Data.List


    For quick GHCi tests, just enter :m +Data.List at the command line to load that module.

    Prelude> :m +Data.List
    Prelude Data.List> :t permutations    
    permutations :: [a] -> a

    Resources:

    https://en.wikibooks.org/wiki/..%2FHierarchical%20libraries
    http://www.haskell.org/onlinereport/standard-prelude.html
    http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
    http://www.haskell.org/hoogle
    https://hackage.haskell.org/
    http://www.haskell.org/cabal/users-guide/
    http://holumbus.fh-wedel.de/hayoo/hayoo.html


-- ---------------------------------------------------------------------------------------------- --
--  11) Cap_9 Next Steps                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --       

    - if/then/else
    - if/then/else by Guards
    - Pattern Matching
    - Tuples and Lists Pattern
    - let bindings

-- ---------------------------------------------------------------------------------------------- --
--  12) Cap_10 Simple input and ouput                                                             -- 
-- ---------------------------------------------------------------------------------------------- --       

    -- ----------------------
    -- Back to the real world
    -- ----------------------
    
      Prelude> putStrLn "Hello, World!"

    putStrLn is one of the standard Prelude tools. As the "putStr" part of the name suggests,
    it takes a String as an argument and prints it to the screen. We could use putStr on its
    own, but we usually include the ”Ln” part so to also print a line break. Thus, whatever else
    is printed next will appear on a new line.

    So now you should be thinking, "what is the type of the putStrLn function?" 
      
    It takes a String and gives... um... what? What do we call that? 
      
    The program doesn't get something back that it can use in another function. 
      
    Instead, the result involves having the computer change the screen. 
    In other words, it does something in the world outside of the program.

    What type could that have? Let's see what GHCi tells us:

        Prelude> :t putStrLn
        putStrLn :: String -> IO ()

    "IO" stands for "input and output"

    Wherever there is IO in a type, interaction with the world outside the program is involved.
    We'll call these IO values actions. 
      
    The other part of the IO type, in this case (), is the type of the return value of the action;
    that is, the type of what it gives back to the program (as opposed to what it does outside 
    the program). 
      
      () (pronounced as ”unit”) is a type that only contains one value also called () 
         (effectively a tuple with zero elements).

    Since putStrLn sends output to the world but doesn't return
    anything to the program, () is used as a placeholder. We might read IO () as 
    "action which returns ()".    

    A few more examples of when we use IO:
    
    - print a string to the screen
    - read a string from a keyboard
    - write data to a file
    - read data from a file

    A complete Haskell program is actually a big IO action. In a compiled program, this action 
    is called main and has type IO (). From this point of view, to write a Haskell program is 
    to combine actions and functions to form the overall action main that will be executed when 
    the program is run. The compiler takes care of instructing the computer on how to do this.    

    -- ----------------------
    -- do notation
    -- ----------------------

    do notation provides a convenient means of putting actions together (which is essential in
    doing useful things with Haskell).

-- ---------------------------------------------------------------------------------------------- --
--  13) Cap_12 Recursion                                                                          -- 
-- ---------------------------------------------------------------------------------------------- -- 

    - Recursion:
       Recursion is the idea of defining a function in terms of itself.

    - List based Recursion 

-- ---------------------------------------------------------------------------------------------- --
--  14) Cap_13 More about Lists                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --           

    - map function
    - Dot Dot Notation
    - Infinite Lists
    - Prelude null fuction
    

-- ---------------------------------------------------------------------------------------------- --
--  15) Cap_14 List Processing                                                                    -- 
-- ---------------------------------------------------------------------------------------------- --      

    - Folds 
        - foldr
        - foldl
        - scans
        - filter
        - List comprehensions

-- ---------------------------------------------------------------------------------------------- --
--  16) Cap_15.Type_Declarations                                                                  -- 
-- ---------------------------------------------------------------------------------------------- --      

    You're not restricted to working with just the types provided by default with the language.
    
    Haskell has three basic ways to declare a new type:

    - The data declaration, which defines new data types.
    - The type declaration for type synonyms, that is, alternative names for existing types.
    - The newtype declaration, which defines new data types equivalent to existing ones.

    - data and constructor functions
    - deconstructing types
    - type for making type synonyms

-- ---------------------------------------------------------------------------------------------- --
--  17) Cap_16.Pattern_Matching                                                                   --
-- ---------------------------------------------------------------------------------------------- --

    - Pattern Matching

    Some languages like Perl and Python use term pattern matching for matching regular expression
    against strings.
    The pattern matching we are referring to in this chapter is something completely different.
    Here pattern matching is used to deconstruct values according  to their type specification.

    - Tuple constructors
    - Matching literal values

    - Syntax_Tricks
        - As-patterns

-- ---------------------------------------------------------------------------------------------- --
--  18) Cap_17.Control_Structures                                                                 --
-- ---------------------------------------------------------------------------------------------- --
    - if and guards revisited
    - Embedding if expressions
    - case expressions
    - Controlling actions, revisited

-- ---------------------------------------------------------------------------------------------- --
--  19) Cap_18.More_on_Functions                                                                  --
-- ---------------------------------------------------------------------------------------------- --

    - let and where:

        As discussed in earlier chapters, let and where are useful in local function definitions. 
        Here, sumStr calls addStr function:

    - Anonymous_Functions - lambdas
    - Operators

-- ---------------------------------------------------------------------------------------------- --
--  20) Cap_19.High_Order_Functions                                                               --
-- ---------------------------------------------------------------------------------------------- --

    A function that takes another function (or several functions) as an argument is called a
    higher-order function.

-- ---------------------------------------------------------------------------------------------- --
--  21) Cap_22.Modules                                                                            --
-- ---------------------------------------------------------------------------------------------- --
Haskell modules 2 are a useful way to group a set of related functionalities into a single 
package and manage different functions that may have the same names. 
The module definition is the first thing that goes in your Haskell file.
A basic module definition looks like: 

      module YourModule where

Note that:

    1. the name of the module begins with a capital letter;
    2. each file contains only one module.      

The name of the file is the name of the module plus the .hs file extension. 
Any dots '.' in the module name are changed for directories.

    - -------------------
    - Qualified imports
    - -------------------

So the module YourModule would be in the file YourModule.hs while a module Foo.Bar would 
be in the file Foo/Bar.hs or Foo\Bar.hs. 
Since the module name must begin with a capital letter, the file name must also start with 
a capital letter.    

import Data.Char (toLower, toUpper) -- import only the functions toLower and toUpper from Data.Char
import Data.List                    -- import everything exported from Data.List
import MyModule                     -- import everything exported from MyModule

Imported datatypes are specified by their name, followed by a list of imported constructors
in parenthesis. For example:

import Data.Tree (Tree(Node)) -- import only the Tree data type and its Node constructor 
                              -- from Data.Tree

What if you import some modules that have overlapping definitions? Or if you import a
module but want to overwrite a function yourself? 

There are three ways to handle these cases: 

    Qualified imports, hiding definitions, and renaming imports.

Qualified imports:

Say MyModule and MyOtherModule both have a definition for remove_e, which removes
all instances of e from a string. However, MyModule only removes lower-case e's, and
MyOtherModule removes both upper and lower case. In this case the following code is
ambiguous:

import MyModule
import MyOtherModule

-- someFunction puts a c in front of the text, and removes all e's from the rest

someFunction :: String -> String
someFunction text = 'c' : remove_e text

It isn't clear which remove_e is meant! To avoid this, use the qualified keyword:

import qualified MyModule
import qualified MyOtherModule

-- Will work, removes lower case e's
someFunction text = 'c' : MyModule.remove_e text 

 -- Will work, removes all e's
someOtherFunction text = 'c' : MyOtherModule.remove_e text

 -- Won't work as there is no remove_e defined
someIllegalFunction text = 'c' : remove_e text

In the latter code snippet, no function named remove_e is available at all. 
When we do qualified imports, all the imported values include the module names
as a prefix. 
Incidentally, you can also use the same prefixes even if you did a regular 
import (in our example, MyModule.remove_e works even if the "qualified" keyword 
isn't included).

    - -------------------
    - Hiding definitions
    - -------------------

Now suppose we want to import both MyModule and MyOtherModule, but we know for sure
we want to remove all e's, not just the lower cased ones. 
It will become really tedious to add MyOtherModule before every call to remove_e. 
Can't we just exclude the remove_e from MyModule?

import MyModule hiding (remove_e)
import MyOtherModule

someFunction text = 'c' : remove_e text

This works because of the word hiding on the import line. 
Whatever follows the "hiding" keyword will not be imported. 
Hide multiple items by listing them with parentheses and comma-separation:

import MyModule hiding (remove_e, remove_f)

Note that algebraic datatypes and type synonyms cannot be hidden. These are always
imported. If you have a datatype defined in multiple imported modules, you must use
qualified names.

    - -------------------
    - Renaming imports
    - -------------------

In this case, both the functions in MyModule and the functions in 
MyCompletelyDifferentModule can be prefixed with My:

import MyModule as My
import MyCompletelyDifferentModule as My

    - -------------------
    - Exporting
    - -------------------

How can we decide which functions are exported and which stay "internal"?

module MyModule (remove_e, add_two) where

add_one blah = blah + 1
remove_e text = filter (/= 'e') text
add_two blah = add_one . add_one $ blah

In this case, only remove_e and add_two are exported. 

While add_two is allowed to make use of add_one, functions in modules that
import MyModule cannot use add_one directly, as it isn't exported.

Datatype export specifications are written similarly to import. You name the type, and
follow with the list of constructors in parenthesis:

module MyModule2 (Tree(Branch, Leaf)) where

data Tree a = Branch {left, right :: Tree a}
| Leaf a


In this case, the module declaration could be rewritten "MyModule2 (Tree(..))", declaring
that all constructors are exported.

Maintaining an export list is good practice not only because it reduces namespace pollu-
tion but also because it enables certain compile-time optimizations 5 which are unavailable
otherwise.

-- ---------------------------------------------------------------------------------------------- --
-- 22) Cap_24.More_on_datatypes                                                                   --  
-- ---------------------------------------------------------------------------------------------- --

    - Enumerations
    - Named Fields (Record Syntax)
    - Parametrized_Types

-- ---------------------------------------------------------------------------------------------- --
-- 23) Cap_26.Classes_and_Types                                                                   --  
-- ---------------------------------------------------------------------------------------------- --    

    - Classes and types 
    - Classes and instances
    - Deriving
    - Class inheritance
    - Type constraints

    




