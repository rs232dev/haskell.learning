

** ********************************************************************************************** **
**                                     Table of contents                                          **
** ********************************************************************************************** **

   1) Create VsCode project
   2) Show   VsCode preferences
   3) Set Vscode terminal
   4) Haskell Main
   5) Haskell Comments
   6) Cap_3_4 Variables_and_Functions
   7) Cap_5 Type Basics
   8) Cap_6 List and Tuples
   9) Cap_7 Type Basics II
  10) Cap_8 Building vocabulary
  11) Cap_9 Next Steps + Pattern Matching     
  12) Cap_10 Simple input and ouput
  13) Cap_12 Recursion
  14) Cap_13 More about Lists
  15) Cap_14 List Processing 
  16) Cap_15.Type_Declarations 
  17) Cap_16.Pattern_Matching   
  18) Cap_17.Control_Structures
  19) Cap_18.More_on_Functions 



-- ---------------------------------------------------------------------------------------------- --
--  1) Create VsCode project                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --

host@hskuser:~/dev/vscode.wks/haskell.learning/haskell.wikibooks$ stack new HaskellBasic new-template
Downloading template "new-template" to create project "HaskellBasic" in HaskellBasic/ ...

The following parameters were needed by the template but not provided: author-name
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-name: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-name:value"


The following parameters were needed by the template but not provided: author-email, author-name, category, copyright, github-username
You can provide them in /home/corrado/.stack/config.yaml, like this:
templates:
  params:
    author-email: value
    author-name: value
    category: value
    copyright: value
    github-username: value
Or you can pass each one as parameters like this:
stack new HaskellBasic new-template -p "author-email:value" -p "author-name:value" -p "category:value" -p "copyright:value" -p "github-username:value"

Looking for .cabal or package.yaml files to use to init the project.
Using cabal packages:

- HaskellBasic/

Selecting the best among 15 snapshots...

Downloaded lts-13.18 build plan.    
Didn't see Chart-1.9.1@sha256:cc50e1e65738ab2d6c30ae9e3f138962f87667d81f7860a0deeca9053f6d21ed,2857 in your package indices.
Updating and trying again.
Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/                                 
Downloading timestamp                                                                            
Downloading snapshot                                                                             
Updating index                                                                                   
Updated package index downloaded                                                                 
Update complete                                                                                  
Populated index cache.    
* Matches lts-13.18

Selected resolver: lts-13.18
Initialising configuration using resolver: lts-13.18
Total number of user packages considered: 1
Writing configuration to file: HaskellBasic/stack.yaml
All done.


-- ---------------------------------------------------------------------------------------------- --
-- 2) Show   VsCode preferences                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --

VsCode Preferences:
Creating User and Workspace Settings
To open your user and workspace settings, use the following VS Code menu command:

    On Windows/Linux - File > Preferences > Settings
    On macOS - Code > Preferences > Settings

You can also open the Settings editor from the Command Palette (Ctrl+Shift+P) with Preferences: Open Settings or use the keyboard shortcut (Ctrl+,).


-- ---------------------------------------------------------------------------------------------- --
--  3) Set Vscode terminal                                                                        -- 
-- ---------------------------------------------------------------------------------------------- --

export LC_ALL=en_US.UTF-8
ghci -isrc:app app/Main.hs
Prelude> :set prompt "\x03BB:"


-- ---------------------------------------------------------------------------------------------- --
-- 4) Haskell Main                                                                                -- 
-- ---------------------------------------------------------------------------------------------- --

module Main where

import Lib
import Cap_3.Variables_and_Functions

main :: IO ()
main = do

    putStrLn "haskell basic course ";    


-- ---------------------------------------------------------------------------------------------- --
-- 5) Haskell Comments                                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

-- single line comment
{--
     multi lines comment
--}

-- ---------------------------------------------------------------------------------------------- --
--  6) Cap_3_4 Variables_and_Functions                                                            -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Local definition
    - Prefix Infix operators
    - Boolean operations
    - Guards

-- ---------------------------------------------------------------------------------------------- --
--  7) Cap_5 Type Basics                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --    

    - Haskell is STRONGLY TYPED

-- ---------------------------------------------------------------------------------------------- --
--  8) Cap_6 List and Tuples                                                                      -- 
-- ---------------------------------------------------------------------------------------------- --    
    - List
    - Building a List
    - List of Lists
    - Tuples
    - Retrieve values
    - Tuples within Tuples
    - Polymorphic types

-- ---------------------------------------------------------------------------------------------- --
--  9) Cap_7 Type Basics II                                                                       -- 
-- ---------------------------------------------------------------------------------------------- --        
    - The Num class

-- ---------------------------------------------------------------------------------------------- --
--  10) Cap_8 Building vocabulary                                                                 -- 
-- ---------------------------------------------------------------------------------------------- --        
    - Function Composition:

        Function Composition is a really simply concept.
        It just means applying one function to a value and then applying another function to the
        result.

    - Prelude and hierarchical libraries:

        Prelude is the core library loaded by default in every Haskell program.

    Alongside with Prelude, there are the hierarchical libraries, which provide a much wider
    range of functionality.
    Although they are provided by default with GHC, they are not loaded automatically like
    Prelude.
    Rather they are distributed as modules, which must be imported into your program.

    ex.

    import Data.List


    For quick GHCi tests, just enter :m +Data.List at the command line to load that module.

    Prelude> :m +Data.List
    Prelude Data.List> :t permutations    
    permutations :: [a] -> a

    Resources:

    https://en.wikibooks.org/wiki/..%2FHierarchical%20libraries
    http://www.haskell.org/onlinereport/standard-prelude.html
    http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
    http://www.haskell.org/hoogle
    https://hackage.haskell.org/
    http://www.haskell.org/cabal/users-guide/
    http://holumbus.fh-wedel.de/hayoo/hayoo.html


-- ---------------------------------------------------------------------------------------------- --
--  11) Cap_9 Next Steps                                                                          -- 
-- ---------------------------------------------------------------------------------------------- --       

    - if/then/else
    - if/then/else by Guards
    - Pattern Matching
    - Tuples and Lists Pattern
    - let bindings

-- ---------------------------------------------------------------------------------------------- --
--  12) Cap_10 Simple input and ouput                                                             -- 
-- ---------------------------------------------------------------------------------------------- --       

    -- ----------------------
    -- Back to the real world
    -- ----------------------
    
      Prelude> putStrLn "Hello, World!"

    putStrLn is one of the standard Prelude tools. As the "putStr" part of the name suggests,
    it takes a String as an argument and prints it to the screen. We could use putStr on its
    own, but we usually include the ”Ln” part so to also print a line break. Thus, whatever else
    is printed next will appear on a new line.

    So now you should be thinking, "what is the type of the putStrLn function?" 
      
    It takes a String and gives... um... what? What do we call that? 
      
    The program doesn't get something back that it can use in another function. 
      
    Instead, the result involves having the computer change the screen. 
    In other words, it does something in the world outside of the program.

    What type could that have? Let's see what GHCi tells us:

        Prelude> :t putStrLn
        putStrLn :: String -> IO ()

    "IO" stands for "input and output"

    Wherever there is IO in a type, interaction with the world outside the program is involved.
    We'll call these IO values actions. 
      
    The other part of the IO type, in this case (), is the type of the return value of the action;
    that is, the type of what it gives back to the program (as opposed to what it does outside 
    the program). 
      
      () (pronounced as ”unit”) is a type that only contains one value also called () 
         (effectively a tuple with zero elements).

    Since putStrLn sends output to the world but doesn't return
    anything to the program, () is used as a placeholder. We might read IO () as 
    "action which returns ()".    

    A few more examples of when we use IO:
    
    - print a string to the screen
    - read a string from a keyboard
    - write data to a file
    - read data from a file

    A complete Haskell program is actually a big IO action. In a compiled program, this action 
    is called main and has type IO (). From this point of view, to write a Haskell program is 
    to combine actions and functions to form the overall action main that will be executed when 
    the program is run. The compiler takes care of instructing the computer on how to do this.    

    -- ----------------------
    -- do notation
    -- ----------------------

    do notation provides a convenient means of putting actions together (which is essential in
    doing useful things with Haskell).

-- ---------------------------------------------------------------------------------------------- --
--  13) Cap_12 Recursion                                                                          -- 
-- ---------------------------------------------------------------------------------------------- -- 

    - Recursion:
       Recursion is the idea of defining a function in terms of itself.

    - List based Recursion 

-- ---------------------------------------------------------------------------------------------- --
--  14) Cap_13 More about Lists                                                                   -- 
-- ---------------------------------------------------------------------------------------------- --           

    - map function
    - Dot Dot Notation
    - Infinite Lists
    - Prelude null fuction
    

-- ---------------------------------------------------------------------------------------------- --
--  15) Cap_14 List Processing                                                                    -- 
-- ---------------------------------------------------------------------------------------------- --      

    - Folds 
        - foldr
        - foldl
        - scans
        - filter
        - List comprehensions

-- ---------------------------------------------------------------------------------------------- --
--  16) Cap_15.Type_Declarations                                                                  -- 
-- ---------------------------------------------------------------------------------------------- --      

    You're not restricted to working with just the types provided by default with the language.
    
    Haskell has three basic ways to declare a new type:

    - The data declaration, which defines new data types.
    - The type declaration for type synonyms, that is, alternative names for existing types.
    - The newtype declaration, which defines new data types equivalent to existing ones.

    - data and constructor functions
    - deconstructing types
    - type for making type synonyms

-- ---------------------------------------------------------------------------------------------- --
--  17) Cap_16.Pattern_Matching                                                                   --
-- ---------------------------------------------------------------------------------------------- --

    - Pattern Matching

    Some languages like Perl and Python use term pattern matching for matching regular expression
    against strings.
    The pattern matching we are referring to in this chapter is something completely different.
    Here pattern matching is used to deconstruct values according  to their type specification.

    - Tuple constructors
    - Matching literal values

    - Syntax_Tricks
        - As-patterns

-- ---------------------------------------------------------------------------------------------- --
--  18) Cap_17.Control_Structures                                                                 --
-- ---------------------------------------------------------------------------------------------- --
    - if and guards revisited
    - Embedding if expressions
    - case expressions
    - Controlling actions, revisited

-- ---------------------------------------------------------------------------------------------- --
--  19) Cap_18.More_on_Functions                                                                  --
-- ---------------------------------------------------------------------------------------------- --

    - let and where:

        As discussed in earlier chapters, let and where are useful in local function definitions. 
        Here, sumStr calls addStr function:

    - Anonymous_Functions - lambdas

        




      



















